<div class="container">
  <canvas id="canvas"></canvas>
  <div class="ui-controls">
    <div class="score">Score: <span id="score-result"></span></div>
    <button id="roll-btn">throw the dice</button>
  </div>
</div>

<style>
  .container {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    flex: 1;
    color: #444444;
    display: flex;
    justify-content: center;
    align-items: center;
    font-family: sans-serif;
  }

  canvas {
    position: absolute;
    top: 0;
    left: 0;
  }

  .ui-controls {
    position: relative;
    width: 100%;
    max-width: 500px;
    user-select: none;
    line-height: 1.5;
    padding: 10px;
  }

  .ui-controls .score {
    margin-left: 0.25em;
  }

  .ui-controls #score-result {
    display: inline-block;
    min-width: 1.8em;
  }

  .ui-controls #roll-btn {
    background-color: #4bc0c8;
    font-weight: bold;
    border: none;
    padding: 0.5em 1em;
    text-decoration: none;
    display: inline-block;
    cursor: pointer;
    margin: 1em 0 0 0;
    transition:
      background-color 0.2s,
      transform 0.1s;
  }

  .ui-controls #roll-btn:active {
    transform: translateY(4px);
  }

  .links {
    position: fixed;
    bottom: 20px;
    right: 20px;
    font-size: 18px;
    font-family: sans-serif;
  }
  a {
    text-decoration: none;
    color: black;
    margin-left: 1em;
  }
  a:hover {
    text-decoration: underline;
  }
  a img.icon {
    display: inline-block;
    height: 1em;
    margin: 0 0 -0.1em 0.3em;
  }
</style>

<script>
  import {
    AmbientLight,
    Group,
    Mesh,
    PerspectiveCamera,
    PlaneGeometry,
    PointLight,
    Scene,
    ShadowMaterial,
    Vector3,
    WebGLRenderer,
  } from "three"

  import { World, Vec3, Body, Plane } from "cannon-es"
  import { OrbitControls } from "three/addons/controls/OrbitControls.js"
  import CannonDebugger from "cannon-es-debugger"

  import { dice } from "./3dObjects/Dice.ts"
  import { board } from "./3dObjects/Board.ts"
  import { table } from "./3dObjects/Table.ts"
  import { jigsaw } from "./demos/Jigsaw.ts"
  import { boardGamePiece } from "./3dObjects/BoardGamePiece"

  const canvasEl = document.querySelector("#canvas")!
  const scoreResult = document.querySelector("#score-result")!
  const rollBtn = document.querySelector("#roll-btn")!

  const renderer = new WebGLRenderer({
    alpha: true,
    antialias: true,
    canvas: canvasEl,
  })

  const scene = new Scene()
  const camera = new PerspectiveCamera(
    45,
    window.innerWidth / window.innerHeight,
    0.1,
    300
  )
  const physicsWorld = new World({
    allowSleep: true,
    gravity: new Vec3(0, -50, 0),
  })
  physicsWorld.defaultContactMaterial.restitution = 0.3
  //@ts-ignore
  // const cannonDebugger = new CannonDebugger(scene, physicsWorld)

  physicsWorld.defaultContactMaterial.contactEquationStiffness = 1e7
  physicsWorld.defaultContactMaterial.contactEquationRelaxation = 4

  // const Dice = dice(scene, physicsWorld)
  const Board = board(scene, physicsWorld)
  const BoardGamePiece = boardGamePiece(scene, physicsWorld)
  // const Jigsaw = jigsaw(scene, physicsWorld)
  table(scene, physicsWorld)

  const controls = new OrbitControls(camera, renderer.domElement)

  type PhysicalObject = {
    model: Group | Mesh
    body: Body
  }

  const diceArray: PhysicalObject[] = []
  // const numberOfDice = 1
  // for (let i = 0; i < numberOfDice; i++) {
  //   diceArray.push(Dice)
  //   addDiceEvents(diceArray[i])
  // }

  initScene()

  window.addEventListener("resize", updateSceneSize)
  window.addEventListener("dblclick", throwDice)
  rollBtn.addEventListener("click", throwDice)

  function initScene() {
    renderer.shadowMap.enabled = true
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2))

    camera.position.set(0, 1.15, 1).multiplyScalar(9)
    camera.lookAt(0, 2, 2)

    updateSceneSize()

    controls.update()

    const ambientLight = new AmbientLight(0xffffff, 0.5)
    scene.add(ambientLight)

    const topLight = new PointLight(0xffffff, 1000)
    topLight.position.set(10, 15, 3)
    topLight.castShadow = true
    topLight.shadow.mapSize.width = 4096
    topLight.shadow.mapSize.height = 4096
    topLight.shadow.camera.near = 5
    topLight.shadow.camera.far = 400
    topLight.shadow.bias = -0.00003
    scene.add(topLight)

    createFloor()

    throwDice()

    render()
  }

  function createFloor() {
    const floor = new Mesh(
      new PlaneGeometry(1000, 1000),
      new ShadowMaterial({
        opacity: 0.15,
      })
    )
    floor.receiveShadow = true
    floor.position.set(0, -7, 0)
    floor.quaternion.setFromAxisAngle(new Vector3(-1, 0, 0), Math.PI / 2)
    scene.add(floor)

    const floorBody = new Body({
      type: Body.STATIC,
      shape: new Plane(),
    })
    floorBody.position.set(floor.position.x, floor.position.y, floor.position.z)
    floorBody.quaternion.set(
      floor.quaternion.x,
      floor.quaternion.y,
      floor.quaternion.z,
      floor.quaternion.w
    )
    physicsWorld.addBody(floorBody)
  }

  function addDiceEvents(dice: PhysicalObject) {
    dice.body.addEventListener("sleep", (e: Event) => {
      dice.body.allowSleep = false

      const euler = new Vec3()
      //@ts-ignore
      e.target.quaternion.toEuler(euler)

      const eps = 0.1
      let isZero = (angle: number) => Math.abs(angle) < eps
      let isHalfPi = (angle: number) => Math.abs(angle - 0.5 * Math.PI) < eps
      let isMinusHalfPi = (angle: number) =>
        Math.abs(0.5 * Math.PI + angle) < eps
      let isPiOrMinusPi = (angle: number) =>
        Math.abs(Math.PI - angle) < eps || Math.abs(Math.PI + angle) < eps

      if (isZero(euler.z)) {
        if (isZero(euler.x)) {
          showRollResults(1)
        } else if (isHalfPi(euler.x)) {
          showRollResults(4)
        } else if (isMinusHalfPi(euler.x)) {
          showRollResults(3)
        } else if (isPiOrMinusPi(euler.x)) {
          showRollResults(6)
        } else {
          // landed on edge => wait to fall on side and fire the event again
          dice.body.allowSleep = true
        }
      } else if (isHalfPi(euler.z)) {
        showRollResults(2)
      } else if (isMinusHalfPi(euler.z)) {
        showRollResults(5)
      } else {
        // landed on edge => wait to fall on side and fire the event again
        dice.body.allowSleep = true
      }
    })
  }

  function showRollResults(score: number) {
    if (scoreResult.innerHTML === "") {
      scoreResult.innerHTML += score
    } else {
      scoreResult.innerHTML += " + " + score
    }
  }

  function syncBodyAndMeshPosition(object: PhysicalObject) {
    object.model.position.set(
      object.body.position.x,
      object.body.position.y,
      object.body.position.z
    )
    object.model.quaternion.set(
      object.body.quaternion.x,
      object.body.quaternion.y,
      object.body.quaternion.z,
      object.body.quaternion.w
    )
  }

  function render() {
    physicsWorld.fixedStep()

    syncBodyAndMeshPosition(Board)
    // diceArray.forEach((dice) => syncBodyAndMeshPosition(dice))
    // Jigsaw.forEach((piece) => syncBodyAndMeshPosition(piece))
    syncBodyAndMeshPosition(BoardGamePiece)
    // cannonDebugger.update()

    controls.update()

    renderer.render(scene, camera)
    requestAnimationFrame(render)
  }

  function updateSceneSize() {
    camera.aspect = window.innerWidth / window.innerHeight
    camera.updateProjectionMatrix()
    renderer.setSize(window.innerWidth, window.innerHeight)
  }

  function throwDice() {
    scoreResult.innerHTML = ""

    diceArray.forEach((d, dIdx) => {
      d.body.velocity.setZero()
      d.body.angularVelocity.setZero()

      d.body.position = new Vec3(4, dIdx * 1.5, -0.5)
      d.model.position.set(
        d.body.position.x,
        d.body.position.y,
        d.body.position.z
      )

      d.model.rotation.set(
        2 * Math.PI * Math.random(),
        0,
        2 * Math.PI * Math.random()
      )
      d.body.quaternion.set(
        d.model.quaternion.x,
        d.model.quaternion.y,
        d.model.quaternion.z,
        d.model.quaternion.w
      )

      const force = 1 + 2 * Math.random()
      d.body.applyImpulse(new Vec3(-force, force, 0), new Vec3(0, 0, 0.2))

      d.body.allowSleep = true
    })
  }
</script>
